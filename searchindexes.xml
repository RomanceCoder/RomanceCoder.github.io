<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>世界，你好！</title><url>/post/hello-world.html</url><categories><category>开始建站</category></categories><tags><tag>Hugo</tag><tag>开始</tag></tags><content type="html"> “使用 weight 关键字置顶文章。”
Hugo
是现今世界上最快的网站建设框架，也是最流行的开源静态站点生成器之一。 凭借其惊人的速度和灵活性，Hugo 让建设网站再次变得有趣起来。
快速开始
发表新文章
$ hugo new hello-world.md 更多信息：
内容格式
启动服务
$ hugo server 更多信息：
Hugo 服务命令行
生成静态文件
$ hugo 更多信息：
Hugo 建站
部署到服务器
$ hugo deploy 更多信息：
Hugo 发布
祝你好运，相信你会喜欢上 Hugo 建站的旅程！</content></entry><entry><title>Deep Copy</title><url>/posts/deep-copy/</url><categories><category>C++</category></categories><tags><tag>C++</tag><tag>deep copy</tag></tags><content type="html"><![CDATA[  开发中的困惑最近在写这样的代码的时候 产生了一个疑问？
如下代码会发生浅拷贝吗？
struct Buffer { UINT32 verify; UINT8 src; UINT8 dest; UINT8 type; UINT32 length; UINT32 num; char data[MAX_DATA_SIZE]; }; class Msg { private: Buffer buf; public: Msg(); void init(const char *data, INT32 data_len); void info() const; }; int main() { Msg msg1; Msg msg2 = msg1;// ? } 写段代码瞧瞧#include &lt;stdio.h&gt; #include &lt;string.h&gt; struct Con{ char data[100]; int * p; }; class Stu{ public: Con c; Stu() { memset(&amp;c, 0, sizeof(c)); c.p = NULL; } }; int main() { Stu s1; strcpy(s1.c.data, &#34;hello&#34;); int a = 3; s1.c.p = &amp;a; printf(&#34;s1.c.data:%p\n&#34;, s1.c.data); printf(&#34;s1.c.p:%p\n&#34;, s1.c.p); Stu s2=s1; printf(&#34;s2.c.data:%p\n&#34;, s2.c.data); printf(&#34;s2.c.p:%p\n&#34;, s2.c.p); } // s1.c.data:0000008f421ff830 // s1.c.p:0000008f421ff82c // s2.c.data:0000008f421ff7b0 // s2.c.p:0000008f421ff82c 解决对象在拷贝构造或者拷贝赋值的时候，是一个字节一个字节拷过去的。
不论是类中的数组 还是 类中的结构体中的数组 不管嵌套多少层
结果都是一样的
指针类型会发生浅拷贝 数组就不会
  ]]></content></entry><entry><title>Git Bash</title><url>/posts/git-bash/</url><categories><category>git</category></categories><tags><tag>git</tag></tags><content type="html"><![CDATA[  git-bash
git-bash在公司服务器上使用zsh总是感觉有点不太稳
罢了 在bash 配置一下git吧
在.bash_aliases中添加如下配置(之前在github上看到https://gist.github.com/vratiu/9780109的 感觉不错 直接拿来用了)
# Customize BASH PS1 prompt to show current GIT repository and branch. # by Mike Stewart - http://MediaDoneRight.com # SETUP CONSTANTS # Bunch-o-predefined colors. Makes reading code easier than escape sequences. # I don&#39;t remember where I found this. o_O # Reset Color_Off=&#34;\[\033[0m\]&#34; # Text Reset # Regular Colors Black=&#34;\[\033[0;30m\]&#34; # Black Red=&#34;\[\033[0;31m\]&#34; # Red Green=&#34;\[\033[0;32m\]&#34; # Green Yellow=&#34;\[\033[0;33m\]&#34; # Yellow Blue=&#34;\[\033[0;34m\]&#34; # Blue Purple=&#34;\[\033[0;35m\]&#34; # Purple Cyan=&#34;\[\033[0;36m\]&#34; # Cyan White=&#34;\[\033[0;37m\]&#34; # White # Bold BBlack=&#34;\[\033[1;30m\]&#34; # Black BRed=&#34;\[\033[1;31m\]&#34; # Red BGreen=&#34;\[\033[1;32m\]&#34; # Green BYellow=&#34;\[\033[1;33m\]&#34; # Yellow BBlue=&#34;\[\033[1;34m\]&#34; # Blue BPurple=&#34;\[\033[1;35m\]&#34; # Purple BCyan=&#34;\[\033[1;36m\]&#34; # Cyan BWhite=&#34;\[\033[1;37m\]&#34; # White # Underline UBlack=&#34;\[\033[4;30m\]&#34; # Black URed=&#34;\[\033[4;31m\]&#34; # Red UGreen=&#34;\[\033[4;32m\]&#34; # Green UYellow=&#34;\[\033[4;33m\]&#34; # Yellow UBlue=&#34;\[\033[4;34m\]&#34; # Blue UPurple=&#34;\[\033[4;35m\]&#34; # Purple UCyan=&#34;\[\033[4;36m\]&#34; # Cyan UWhite=&#34;\[\033[4;37m\]&#34; # White # Background On_Black=&#34;\[\033[40m\]&#34; # Black On_Red=&#34;\[\033[41m\]&#34; # Red On_Green=&#34;\[\033[42m\]&#34; # Green On_Yellow=&#34;\[\033[43m\]&#34; # Yellow On_Blue=&#34;\[\033[44m\]&#34; # Blue On_Purple=&#34;\[\033[45m\]&#34; # Purple On_Cyan=&#34;\[\033[46m\]&#34; # Cyan On_White=&#34;\[\033[47m\]&#34; # White # High Intensty IBlack=&#34;\[\033[0;90m\]&#34; # Black IRed=&#34;\[\033[0;91m\]&#34; # Red IGreen=&#34;\[\033[0;92m\]&#34; # Green IYellow=&#34;\[\033[0;93m\]&#34; # Yellow IBlue=&#34;\[\033[0;94m\]&#34; # Blue IPurple=&#34;\[\033[0;95m\]&#34; # Purple ICyan=&#34;\[\033[0;96m\]&#34; # Cyan IWhite=&#34;\[\033[0;97m\]&#34; # White # Bold High Intensty BIBlack=&#34;\[\033[1;90m\]&#34; # Black BIRed=&#34;\[\033[1;91m\]&#34; # Red BIGreen=&#34;\[\033[1;92m\]&#34; # Green BIYellow=&#34;\[\033[1;93m\]&#34; # Yellow BIBlue=&#34;\[\033[1;94m\]&#34; # Blue BIPurple=&#34;\[\033[1;95m\]&#34; # Purple BICyan=&#34;\[\033[1;96m\]&#34; # Cyan BIWhite=&#34;\[\033[1;97m\]&#34; # White # High Intensty backgrounds On_IBlack=&#34;\[\033[0;100m\]&#34; # Black On_IRed=&#34;\[\033[0;101m\]&#34; # Red On_IGreen=&#34;\[\033[0;102m\]&#34; # Green On_IYellow=&#34;\[\033[0;103m\]&#34; # Yellow On_IBlue=&#34;\[\033[0;104m\]&#34; # Blue On_IPurple=&#34;\[\033[10;95m\]&#34; # Purple On_ICyan=&#34;\[\033[0;106m\]&#34; # Cyan On_IWhite=&#34;\[\033[0;107m\]&#34; # White # Various variables you might want for your PS1 prompt instead Time12h=&#34;\T&#34; Time12a=&#34;\@&#34; PathShort=&#34;\w&#34; PathFull=&#34;\W&#34; NewLine=&#34;\n&#34; Jobs=&#34;\j&#34; # This PS1 snippet was adopted from code for MAC/BSD I saw from: http://allancraig.net/index.php?option=com_content&amp;view=article&amp;id=108:ps1-export-command-for-git&amp;catid=45:general&amp;Itemid=96 # I tweaked it to work on UBUNTU 11.04 &amp; 11.10 plus made it mo&#39; better export PS1=$IBlack$Time12h$Color_Off&#39;$(git branch &amp;&gt;/dev/null;\ if [ $? -eq 0 ]; then \ echo &#34;$(echo `git status` | grep &#34;nothing to commit&#34; &gt; /dev/null 2&gt;&amp;1; \ if [ &#34;$?&#34; -eq &#34;0&#34; ]; then \ # @4 - Clean repository - nothing to commit echo &#34;&#39;$Green&#39;&#34;$(__git_ps1 &#34; (%s)&#34;); \ else \ # @5 - Changes to working tree echo &#34;&#39;$IRed&#39;&#34;$(__git_ps1 &#34; {%s}&#34;); \ fi) &#39;$BYellow$PathShort$Color_Off&#39;\$ &#34;; \ else \ # @2 - Prompt when not in GIT repo echo &#34; &#39;$Yellow$PathShort$Color_Off&#39;\$ &#34;; \ fi)&#39; # enable this flag ONLY if you are working with an internal repository that doesn&#39;t have a valid certificate # export GIT_SSL_NO_VERIFY=true git config --global alias.lg &#34;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&#34;   ]]></content></entry><entry><title>Master Talk</title><url>/posts/master-talk/</url><categories><category>侯婕</category></categories><tags><tag>侯婕</tag></tags><content type="html"> 侯捷先生讲座, 与大家共勉.
● 「程序人生」演讲内容摘要。
如果你不曾听过侯捷的名字，不曾知道侯捷做的事情，你不可能有兴趣走入会场。因此，各位远道而来，我窃以为，无非想看看侯捷本人，听听他说话。如果 你期盼在这种场合听到某某技术的剖析，某某趋势的发展，肯定你会失望。我不是趋势专家，对此也毫无兴趣。台上说话和台下聊天不同，我不能也不敢讲我没有心 得没有研究的话题。「程序人生」这个话题旨在让大家对一个你感兴趣的人（侯捷我）的学习历程有些了解，或许从中给你一些灵感或激励。
我在一个被昵称为「少林寺」的地方，磨练三年。後半期因为发现了自己浓烈的兴趣与不错的天赋，决定转向技术写作与教育这条路。30岁之後的我，行事 常思「贡献度」，我知道自己在技术写作与教育这条路上能够走得比程式开发更好，所以决定把自己摆在最适当的位置。一口食物，放在嘴里是佳肴，吐出来就成了 秽物。天生我材必有用，每个人都应该仔细思考，自己真正的兴趣和才能在哪里。很多人都问，30岁之後做不动程序员了怎麽办。30年正是英年，体力和智力和 成熟度都正达到巅峰，怎麽会做不动程序？想往管理阶层走当然很好，那就努力充实自己，并且扪心自问，你做管理快乐吗？要知道，人事绝对比机器让你更焦头烂 额。如果你决定争取一个粥少僧多的职位，就不要再问「怎麽办」。还能怎麽办呢？就努力以赴呀！比赛还没开始就问「输了怎麽办」，这不像话，你注定要输。
技术养成阶段，对我影响最大的一件事是，我自动请缨做一套公用程式库，目标给全部门乃至全所使用。这使我学习到技术的整理、文件 （documents）的撰写、人际的沟通。重要的不在具体实作，而在多方培养了正确观念。如果你问我，对於程式，我最重视什麽？我最重视可读性（含说明 文件）、维护性、复用性，完整性。这些其实是一体多面。
转向技术写作後，我的生活和待在业界没有什麽改变，只不过业界的产出是软体，我的产出是书籍和文章。写一本书和规划一个专案（project）没什麽两样。但是，专心於技术写作之後，从此我有绝对的自由钻研我最感兴趣的「技术本质」与「技术核心」。
我周遭的朋友，但凡表现不凡者，都有非凡的资料整理功夫。如今网络发达，资讯爆炸，硬碟又便宜，资料整理功夫更显重要。没有经过自己整理的资料，形 同垃圾。许多人喜欢上网「收集」一大堆电子书、电子文档。你得想个办法把这些庞大的资料化为你的图书馆，而不是 …</content></entry><entry><title>argc</title><url>/posts/argc/</url><categories><category>C</category></categories><tags><tag>C</tag></tags><content type="html"><![CDATA[  C中的argc和argv#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;basetsd.h&gt; int main(int argc, char * argv[]) { std::cout &lt;&lt; &#34;Hello, World!&#34; &lt;&lt; std::endl; for (int i = 0; i &lt; argc; ++i) { printf(&#34;%d:%s\n&#34;, i, argv[i]); } printf(&#34;parse hex:\n&#34;); UINT32 hex; sscanf(argv[1], &#34;0x%x&#34;, &amp;hex); printf(&#34;0x%x\n&#34;, hex); printf(&#34;parse double:\n&#34;); double f0; sscanf(argv[2], &#34;%lf&#34;, &amp;f0); printf(&#34;%lf\n&#34;, f0); return 0; }   ]]></content></entry><entry><title>git_tag</title><url>/posts/git_tag/</url><categories><category>Git</category></categories><tags><tag>git</tag></tags><content type="html"><![CDATA[  本地仓库打tag本地仓库打标签可以用附注标签或者轻量标签 然后更新远端
附注标签git tag -a V3.0.1 -m &#34;V3.0.3&#34; # git tag -a &lt;tag-name&gt; -m &#34;...&#34; 轻量标签git tag V3.0.1 # git tag &lt;tag-name&gt; 更新远端方式一git push origin V3.0.1 # git push &lt;remote&gt; &lt;tag-name&gt; 更新远端方式二git push origin --tags # git push &lt;remote&gt; --tags 本地仓库删tag删除本地标签 然后更新远端
git tag -d V3.0.1 # git tag -d &lt;tag-name&gt; 更新远端方式一git push origin :refs/tags/V3.0.1 # git push &lt;remote&gt; :refs/tags/&lt;tag-name&gt; 更新远端方式二git push origin --delete V3.0.1 # git push &lt;remote&gt; --delete &lt;tag-name&gt; tag冲突拉取远端tag本地有远端同名的tag 需要先delete本地的tag 再拉取远端的tag
git tag -d V5.2.7 # git tag -d &lt;tag-name&gt; git fetch origin # git fetch &lt;remote&gt; 推送本地tag远端有本地同名的tag 需要先delete远端的tag 再拉推送本地tag
git push origin --delte V5.2.7 # git push &lt;remote&gt; --delete &lt;tag-name&gt; git push origin --tags # git push &lt;remote&gt; --tags   ]]></content></entry><entry><title>printf</title><url>/posts/printf/</url><categories><category>C</category></categories><tags><tag>C</tag></tags><content type="html"><![CDATA[  C语言中的printf我们常常使用C中标准库自带的printf打印内容
例如：
#include &lt;stdio.h&gt; int main(){ printf(&#34;hello,world\n&#34;); return 0; } C语言中的printf打印十六进制#include &lt;stdio.h&gt; int main(){ printf(&#34;0x%x | 0x%X \n&#34;, 0x1a, 0x1a); //==&gt; 0x1a | 0x1A printf(&#34;0x%04x | 0x%04X \n&#34;, 0x1a, 0x1a); //==&gt; 0x001a | 0x001A return 0; }   ]]></content></entry></search>